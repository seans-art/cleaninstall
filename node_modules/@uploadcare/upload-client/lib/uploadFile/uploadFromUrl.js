"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fromUrlStatus_1 = require("../api/fromUrlStatus");
var fromUrl_1 = require("../api/fromUrl");
var errors_1 = require("../tools/errors");
var poll_1 = require("../tools/poll");
var race_1 = require("../tools/race");
var isReadyPoll_1 = require("../tools/isReadyPoll");
var defaultSettings_1 = require("../defaultSettings");
var pusher_1 = require("./pusher");
var UploadcareFile_1 = require("../tools/UploadcareFile");
function pollStrategy(_a) {
    var token = _a.token, publicKey = _a.publicKey, baseURL = _a.baseURL, integration = _a.integration, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, onProgress = _a.onProgress, cancel = _a.cancel;
    return poll_1.poll({
        check: function (cancel) {
            return fromUrlStatus_1.default(token, {
                publicKey: publicKey,
                baseURL: baseURL,
                integration: integration,
                retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                cancel: cancel
            }).then(function (response) {
                switch (response.status) {
                    case fromUrlStatus_1.Status.Error: {
                        return new errors_1.UploadClientError(response.error);
                    }
                    case fromUrlStatus_1.Status.Waiting: {
                        return false;
                    }
                    case fromUrlStatus_1.Status.Unknown: {
                        return new errors_1.UploadClientError("Token \"" + token + "\" was not found.");
                    }
                    case fromUrlStatus_1.Status.Progress: {
                        if (onProgress)
                            onProgress({ value: response.done / response.total });
                        return false;
                    }
                    case fromUrlStatus_1.Status.Success: {
                        if (onProgress)
                            onProgress({ value: response.done / response.total });
                        return response;
                    }
                    default: {
                        throw new Error('Unknown status');
                    }
                }
            });
        },
        cancel: cancel
    });
}
var pushStrategy = function (_a) {
    var token = _a.token, pusherKey = _a.pusherKey, cancel = _a.cancel, stopRace = _a.stopRace, onProgress = _a.onProgress;
    return new Promise(function (resolve, reject) {
        var pusher = pusher_1.getPusher(pusherKey);
        var unsubErrorHandler = pusher.onError(reject);
        var destroy = function () {
            unsubErrorHandler();
            pusher.unsubscribe(token);
        };
        cancel.onCancel(function () {
            destroy();
            reject(errors_1.cancelError('pisher cancelled'));
        });
        pusher.subscribe(token, function (result) {
            stopRace();
            switch (result.status) {
                case fromUrlStatus_1.Status.Progress: {
                    if (onProgress) {
                        onProgress({ value: result.done / result.total });
                    }
                    break;
                }
                case fromUrlStatus_1.Status.Success: {
                    destroy();
                    if (onProgress)
                        onProgress({ value: result.done / result.total });
                    resolve(result);
                    break;
                }
                case fromUrlStatus_1.Status.Error: {
                    destroy();
                    reject(new errors_1.UploadClientError(result.msg));
                }
            }
        });
    });
};
var uploadFromUrl = function (sourceUrl, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, baseURL = _a.baseURL, baseCDN = _a.baseCDN, checkForUrlDuplicates = _a.checkForUrlDuplicates, saveUrlForRecurrentUploads = _a.saveUrlForRecurrentUploads, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, cancel = _a.cancel, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, _b = _a.pusherKey, pusherKey = _b === void 0 ? defaultSettings_1.default.pusherKey : _b;
    return Promise.resolve(pusher_1.preconnect(pusherKey))
        .then(function () {
        return fromUrl_1.default(sourceUrl, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            checkForUrlDuplicates: checkForUrlDuplicates,
            saveUrlForRecurrentUploads: saveUrlForRecurrentUploads,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            cancel: cancel,
            source: source,
            integration: integration,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
        });
    })
        .then(function (urlResponse) {
        if (urlResponse.type === fromUrl_1.TypeEnum.FileInfo) {
            return urlResponse;
        }
        else {
            return race_1.race([
                function (_a) {
                    var cancel = _a.cancel;
                    return pollStrategy({
                        token: urlResponse.token,
                        publicKey: publicKey,
                        baseURL: baseURL,
                        integration: integration,
                        retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
                        onProgress: onProgress,
                        cancel: cancel
                    });
                },
                function (_a) {
                    var stopRace = _a.stopRace, cancel = _a.cancel;
                    return pushStrategy({
                        token: urlResponse.token,
                        pusherKey: pusherKey,
                        stopRace: stopRace,
                        cancel: cancel,
                        onProgress: onProgress
                    });
                }
            ], { cancel: cancel });
        }
    })
        .then(function (result) {
        if (result instanceof errors_1.UploadClientError)
            throw result;
        return result;
    })
        .then(function (result) {
        return isReadyPoll_1.isReadyPoll({
            file: result.uuid,
            publicKey: publicKey,
            baseURL: baseURL,
            integration: integration,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            onProgress: onProgress,
            cancel: cancel
        });
    })
        .then(function (fileInfo) { return new UploadcareFile_1.UploadcareFile(fileInfo, { baseCDN: baseCDN }); });
};
exports.default = uploadFromUrl;
