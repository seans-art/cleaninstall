"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../tools/errors");
var request = function (_a) {
    var method = _a.method, url = _a.url, data = _a.data, _b = _a.headers, headers = _b === void 0 ? {} : _b, cancel = _a.cancel, onProgress = _a.onProgress;
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        var requestMethod = (method === null || method === void 0 ? void 0 : method.toUpperCase()) || 'GET';
        var aborted = false;
        xhr.open(requestMethod, url);
        if (headers) {
            Object.entries(headers).forEach(function (entry) {
                var key = entry[0], value = entry[1];
                typeof value !== 'undefined' &&
                    !Array.isArray(value) &&
                    xhr.setRequestHeader(key, value);
            });
        }
        xhr.responseType = 'text';
        if (cancel) {
            cancel.onCancel(function () {
                aborted = true;
                xhr.abort();
                reject(errors_1.cancelError());
            });
        }
        xhr.onload = function () {
            if (xhr.status != 200) {
                // analyze HTTP status of the response
                reject(new Error("Error " + xhr.status + ": " + xhr.statusText)); // e.g. 404: Not Found
            }
            else {
                var request_1 = {
                    method: requestMethod,
                    url: url,
                    data: data,
                    headers: headers || undefined,
                    cancel: cancel,
                    onProgress: onProgress
                };
                // Convert the header string into an array
                // of individual headers
                var headersArray = xhr
                    .getAllResponseHeaders()
                    .trim()
                    .split(/[\r\n]+/);
                // Create a map of header names to values
                var responseHeaders_1 = {};
                headersArray.forEach(function (line) {
                    var parts = line.split(': ');
                    var header = parts.shift();
                    var value = parts.join(': ');
                    if (header && typeof header !== 'undefined') {
                        responseHeaders_1[header] = value;
                    }
                });
                var responseData = xhr.response;
                var responseStatus = xhr.status;
                resolve({
                    request: request_1,
                    data: responseData,
                    headers: responseHeaders_1,
                    status: responseStatus
                });
            }
        };
        xhr.onerror = function () {
            if (aborted)
                return;
            // only triggers if the request couldn't be made at all
            reject(new Error('Network error'));
        };
        if (onProgress && typeof onProgress === 'function') {
            xhr.upload.onprogress = function (event) {
                onProgress({ value: event.loaded / event.total });
            };
        }
        if (data) {
            xhr.send(data);
        }
        else {
            xhr.send();
        }
    });
};
exports.default = request;
