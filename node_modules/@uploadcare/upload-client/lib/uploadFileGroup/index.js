"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var uploadFile_1 = require("../uploadFile");
var defaultSettings_1 = require("../defaultSettings");
var group_1 = require("../api/group");
var UploadcareGroup_1 = require("../tools/UploadcareGroup");
/* Types */
var types_1 = require("./types");
/**
 * Uploads file from provided data.
 * @param data
 * @param options
 * @param [options.publicKey]
 * @param [options.fileName]
 * @param [options.baseURL]
 * @param [options.secureSignature]
 * @param [options.secureExpire]
 * @param [options.store]
 * @param [options.cancel]
 * @param [options.onProgress]
 * @param [options.source]
 * @param [options.integration]
 * @param [options.retryThrottledRequestMaxTimes]
 * @param [options.contentType]
 * @param [options.multipartChunkSize]
 * @param [options.baseCDN]
 */
function uploadFileGroup(data, _a) {
    var publicKey = _a.publicKey, fileName = _a.fileName, _b = _a.baseURL, baseURL = _b === void 0 ? defaultSettings_1.default.baseURL : _b, secureSignature = _a.secureSignature, secureExpire = _a.secureExpire, store = _a.store, cancel = _a.cancel, onProgress = _a.onProgress, source = _a.source, integration = _a.integration, retryThrottledRequestMaxTimes = _a.retryThrottledRequestMaxTimes, contentType = _a.contentType, _c = _a.multipartChunkSize, multipartChunkSize = _c === void 0 ? defaultSettings_1.default.multipartChunkSize : _c, _d = _a.baseCDN, baseCDN = _d === void 0 ? defaultSettings_1.default.baseCDN : _d, jsonpCallback = _a.jsonpCallback, defaultEffects = _a.defaultEffects;
    if (!types_1.isFileDataArray(data) && !types_1.isUrlArray(data) && !types_1.isUuidArray(data)) {
        throw new TypeError("Group uploading from \"" + data + "\" is not supported");
    }
    var progressValues;
    var filesCount = data.length;
    var createProgressHandler = function (size, index) {
        if (!onProgress)
            return;
        if (!progressValues) {
            progressValues = Array(size).fill(0);
        }
        var normalize = function (values) {
            return values.reduce(function (sum, next) { return sum + next; }) / size;
        };
        return function (_a) {
            var value = _a.value;
            progressValues[index] = value;
            onProgress({ value: normalize(progressValues) });
        };
    };
    return Promise.all(data.map(function (file, index) {
        return uploadFile_1.default(file, {
            publicKey: publicKey,
            fileName: fileName,
            baseURL: baseURL,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            store: store,
            cancel: cancel,
            onProgress: createProgressHandler(filesCount, index),
            source: source,
            integration: integration,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes,
            contentType: contentType,
            multipartChunkSize: multipartChunkSize,
            baseCDN: baseCDN
        });
    })).then(function (files) {
        var uuids = files.map(function (file) { return file.uuid; });
        var addDefaultEffects = function (file) {
            var cdnUrlModifiers = defaultEffects ? "-/" + defaultEffects : null;
            var cdnUrl = "" + file.urlBase + (cdnUrlModifiers || '');
            return __assign(__assign({}, file), { cdnUrlModifiers: cdnUrlModifiers,
                cdnUrl: cdnUrl });
        };
        var filesInGroup = defaultEffects ? files.map(addDefaultEffects) : files;
        return group_1.default(uuids, {
            publicKey: publicKey,
            baseURL: baseURL,
            jsonpCallback: jsonpCallback,
            secureSignature: secureSignature,
            secureExpire: secureExpire,
            cancel: cancel,
            source: source,
            integration: integration,
            retryThrottledRequestMaxTimes: retryThrottledRequestMaxTimes
        }).then(function (groupInfo) { return new UploadcareGroup_1.UploadcareGroup(groupInfo, filesInGroup); });
    });
}
exports.default = uploadFileGroup;
